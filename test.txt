package com.foreign.travel.controller;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.net.URI;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.foreign.travel.domain.ForeignTravelAudit;
import com.foreign.travel.dto.common.PageResponse;
import com.foreign.travel.dto.foreigntravel.AttachmentResponse;
import com.foreign.travel.dto.foreigntravel.ForeignTravelRequest;
import com.foreign.travel.dto.foreigntravel.ForeignTravelResponse;
import com.foreign.travel.service.ForeignTravelService;
import jakarta.servlet.ServletOutputStream;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.net.URI;
import java.util.*;
import java.util.stream.Collectors;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
public class ForeignTravelController {

    private final ForeignTravelService service;

    public ForeignTravelController(ForeignTravelService service) {
        this.service = service;
    }

    @PostMapping("/travel")
    public ResponseEntity<ForeignTravelResponse> create(
            @Valid @RequestBody ForeignTravelRequest request,
            @RequestParam(value = "certify", required = false, defaultValue = "false") boolean certify,
            @RequestParam(value = "spGlobalId", required = false) String spGlobalId) {

        ForeignTravelResponse response = service.saveInitial(request, certify, spGlobalId);

        URI location = URI.create(String.format("/api/travel/%s/%s",
                response.getRecordId(), response.getVersionId()));

        return ResponseEntity.created(location).body(response);
    }

    @PutMapping("/travel/{recordId}")
    public ResponseEntity<ForeignTravelResponse> updateLatest(
            @PathVariable("recordId") UUID recordId,
            @Valid @RequestBody ForeignTravelRequest request) {

        ForeignTravelResponse response = service.update(recordId, null, request);
        return ResponseEntity.ok(response);
    }

    @PutMapping("/travel/{recordId}/{versionId}")
    public ResponseEntity<ForeignTravelResponse> updateVersion(
            @PathVariable("recordId") UUID recordId,
            @PathVariable("versionId") Integer versionId,
            @Valid @RequestBody ForeignTravelRequest request) {

        ForeignTravelResponse response = service.update(recordId, versionId, request);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/travel/{recordId}")
    public ResponseEntity<ForeignTravelResponse> getLatest(@PathVariable("recordId") UUID recordId) {
        return ResponseEntity.ok(service.findLatest(recordId));
    }

    @GetMapping("/travel/{recordId}/{versionId}")
    public ResponseEntity<ForeignTravelResponse> getById(
            @PathVariable("recordId") UUID recordId,
            @PathVariable("versionId") Integer versionId) {

        return ResponseEntity.ok(service.findById(recordId, versionId));
    }

    @GetMapping("/travel-list")
    public ResponseEntity<PageResponse<ForeignTravelResponse>> findAll(
            @RequestParam(value = "status", required = false) String status,
            @PageableDefault(size = 20) Pageable pageable) {

        Page<ForeignTravelResponse> page = service.list(Optional.ofNullable(status), pageable);
        return ResponseEntity.ok(PageResponse.from(page));
    }

    @DeleteMapping("/travel/{recordId}/{versionId}")
    public ResponseEntity<Void> delete(@PathVariable("recordId") UUID recordId,
                                       @PathVariable("versionId") Integer versionId) {
        service.delete(recordId, versionId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/travel/{recordId}/certify")
    public ResponseEntity<ForeignTravelResponse> certify(
            @PathVariable("recordId") UUID recordId,
            @RequestParam(value = "version", required = false) Integer versionId) {

        // If a specific version was requested, ensure it exists before certifying.
        if (versionId != null) {
            service.findById(recordId, versionId); // will throw if not found
            // service currently certifies by recordId (appends a certified version).
            // We proceed to certify the record (the service will create a new certified version).
        }

        ForeignTravelResponse response = service.certify(recordId);
        return ResponseEntity.ok(response);
    }



    @PostMapping("/export-list")
    public void exportSelectedForeignTravels(
            @RequestBody List<UUID> recordIds,
            HttpServletResponse response) throws IOException {

        response.setContentType("text/csv");
        response.setHeader("Content-Disposition", "attachment; filename=\"travels.csv\"");

        List<ForeignTravelResponse> travelRecords = service.getExportListByRecordIds(recordIds);

        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()
                .setHeader("RecordId", "Version", "Countries", "From Date", "To Date", "Status", "Details", "Created Date", "Updated Date")
                .build();

        try (ServletOutputStream outputStream = response.getOutputStream();
             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream));
             CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat)) {

            for (ForeignTravelResponse record : travelRecords) {
                String countries = record.getCountries() != null
                        ? String.join(",", Arrays.stream(record.getCountries()).filter(Objects::nonNull).collect(Collectors.toList()))
                        : "";

                csvPrinter.printRecord(
                        record.getRecordId(),
                        record.getVersionId(),
                        countries,
                        record.getStartDate(),
                        record.getEndDate(),
                        record.getStatus(),
                        record.getDetails() != null ? record.getDetails().toString() : "",
                        record.getCreatedAt(),
                        record.getUpdatedAt()
                );
            }
            csvPrinter.flush();
        }
    }
}

-------------------------

package com.foreign.travel.config;

import com.foreign.travel.security.JwtAuthenticationEntryPoint;
import com.foreign.travel.security.JwtAuthenticationFilter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    private final String contextPath;
    private final boolean jwtEnabled;
    private final boolean mockProfileActive;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter,
                          JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint,
                          @Value("${server.servlet.context-path:/}") String contextPath,
                          @Value("${security.jwt.enabled:true}") boolean jwtEnabled,
                          Environment environment) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
        this.jwtAuthenticationEntryPoint = jwtAuthenticationEntryPoint;
        this.contextPath = normalizeContextPath(contextPath);
        this.jwtEnabled = jwtEnabled;
        this.mockProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("mock");
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .headers(headers -> headers
                        .contentSecurityPolicy(csp -> csp.policyDirectives(
                                "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; "
                                        + "img-src 'self' data:; font-src 'self'"))
                        .frameOptions(frame -> frame.sameOrigin()))
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        if (jwtEnabled && !mockProfileActive) {
            http.exceptionHandling(exceptions -> exceptions.authenticationEntryPoint(jwtAuthenticationEntryPoint))
                    .authorizeHttpRequests(authz -> authz
                            .requestMatchers(publicEndpoints()).permitAll()
                            .anyRequest().authenticated())
                    .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        } else {
            http.authorizeHttpRequests(authz -> authz.anyRequest().permitAll());
        }
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        List<String> allowedOriginPatterns = new ArrayList<>(List.of("http://localhost:3000", "http://localhost:3001"));
        if (mockProfileActive) {
            allowedOriginPatterns.add("*");
        }
        configuration.setAllowedOriginPatterns(allowedOriginPatterns);
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    private String[] publicEndpoints() {
        List<String> basePaths = new ArrayList<>(List.of(
                "/swagger-ui/**",
                "/swagger-ui.html",
                "/swagger-resources/**",
                "/api-docs/**",
                "/v3/api-docs/**",
                "/swagger-initializer.js",
                "/webjars/**",
                "/jwt-test/**",
                "/actuator/health",
                "/actuator/info",
                "/health",
                "/error"
        ));

        if (!contextPath.isEmpty()) {
            basePaths.addAll(basePaths.stream()
                    .map(path -> contextPath + (path.startsWith("/") ? path : "/" + path))
                    .collect(Collectors.toSet()));
        }

        return basePaths.stream().distinct().toArray(String[]::new);
    }

    private String normalizeContextPath(String rawContextPath) {
        if (rawContextPath == null || rawContextPath.isBlank() || "/".equals(rawContextPath.trim())) {
            return "";
        }
        String trimmed = rawContextPath.trim();
        return trimmed.endsWith("/") ? trimmed.substring(0, trimmed.length() - 1) : trimmed;
    }
}

----

# Local Development Profile Configuration
server.port=9090

# JWT Configuration for Local Development
# Use public certificate for JWT validation
security.jwt.certificate-path=ssl-local/localhost.crt

-----

