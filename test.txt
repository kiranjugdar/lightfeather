eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiIwMHV3dWV3dnBobjRBbWFkVjBrNiIsImlhdCI6MTc2MzcyNzQ0MiwiZXhwIjoxNzYzNzQ1NDQyLCJwZXJtaXNzaW9ucyI6WyJpZXAtdXNlciJdLCJodWJVc2VySWQiOiI4ZGU4OGM2Ny0wMWM3LTQ1YTEtODQzOC05YjRjNjE0YWY2NjgiLCJzcEdsb2JhbElkIjoidWNvbjkwNjczMCIsIm5iaXNHbG9iYWxVc2VySUQiOiI0N2E2ZjQwMDNiMDQ5NmZjODIzNzU0ZDQ1NjUzOThkNWQzYTMxMDExODI3OTVmNDkzYmZhZDU4YjRiMjU4YTg0In0.ZFqEWp62DNd_YXwKtnT_cJoacjYadygOMXwI8hq4zDPIdOqTuSbVh623EaL_Ga57CSQB_VD8b2tWGD-YBwPCkXszSENuMjCR8b92y4wJEIYsHUkfXpZd6P7uwdYsFYPy_MnywGIcF_CYg_Id27pz3V_g5nb4nZlvPE55umjEvpyqvpllS_QZfmoPSd5h8gkgBMM57oxq5s3xIRiQb6nnodqeTj4oRSGz68x-SHsLg1IENjbUsvDmL5UjDqVuPocOOmgyc5M84F3Cjmdf_0lIBb1b1o9kdnxJj9zeMzgNbv2oYrjC3xAA9cWm-0XNECt15k5d3hl-anUNc-PXpLl8uQ
-------------

package com.foreign.travel.service;

import com.foreign.travel.domain.ForeignTravelRecord;
import com.foreign.travel.domain.Individual;
import com.foreign.travel.dto.foreigntravel.ForeignTravelRequest;
import com.foreign.travel.dto.foreigntravel.ForeignTravelResponse;
import com.foreign.travel.exception.ResourceNotFoundException;
import com.foreign.travel.repository.ForeignTravelRecordRepository;
import com.foreign.travel.repository.IndividualRepository;
import com.foreign.travel.security.JwtUtil;
import com.foreign.travel.security.SecurityContextHelper;
import jakarta.transaction.Transactional;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

@Service
@Transactional
@Slf4j
public class ForeignTravelService {

    private final ForeignTravelRecordRepository repository;
    private final SecurityContextHelper securityHelper;
    private final IndividualRepository individualRepository;
    private final JwtUtil jwtUtil;

    public ForeignTravelService(ForeignTravelRecordRepository repository,
                               SecurityContextHelper securityHelper,
                               IndividualRepository individualRepository,
                                JwtUtil jwtUtil) {
        this.repository = repository;
        this.securityHelper = securityHelper;
        this.individualRepository = individualRepository;
        this.jwtUtil = jwtUtil;
    }

    public ForeignTravelResponse create(ForeignTravelRequest request) {
        return create(request, null);
    }

    public ForeignTravelResponse create(ForeignTravelRequest request, String spGlobalId) {
        ForeignTravelRecord entity = new ForeignTravelRecord();
        entity.setRecordId(UUID.randomUUID());
        entity.setVersionId(1); // First version
        copyRequestToEntity(request, entity);

        // Get or create user and associate with travel
        Individual user = getOrCreateUser();
        entity.setUserId(user.getUserId());

        // Set timestamps
        OffsetDateTime now = OffsetDateTime.now();
        entity.setCreatedAt(now);
        entity.setUpdatedAt(now);

        ForeignTravelRecord saved = repository.save(entity);

        return mapToResponse(saved, true);
    }

    @Transactional
    public ForeignTravelResponse update(UUID id, ForeignTravelRequest request) {
        // Find the latest version of the record
        ForeignTravelRecord existing = repository
                .findLatestByRecordId(id)
                .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s not found".formatted(id)));

        // Create a new version
        ForeignTravelRecord newVersion = new ForeignTravelRecord();
        newVersion.setRecordId(existing.getRecordId());
        newVersion.setVersionId(existing.getVersionId() + 1);
        newVersion.setUserId(existing.getUserId());

        copyRequestToEntity(request, newVersion);

        // Set timestamps
        newVersion.setCreatedAt(existing.getCreatedAt()); // Keep original creation time
        newVersion.setUpdatedAt(OffsetDateTime.now());

        ForeignTravelRecord saved = repository.save(newVersion);

        return mapToResponse(saved, true);
    }

    @Transactional
    public void delete(UUID id) {
        ForeignTravelRecord existing = repository
                .findLatestByRecordId(id)
                .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s not found".formatted(id)));

        // Delete all versions of this record
        repository.deleteById(new ForeignTravelRecord.ForeignTravelRecordId(existing.getRecordId(), existing.getVersionId()));
    }

    @Transactional(Transactional.TxType.SUPPORTS)
    public ForeignTravelResponse findById(UUID id) {
        ForeignTravelRecord entity = repository
                .findLatestByRecordId(id)
                .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s not found".formatted(id)));
        return mapToResponse(entity, true);
    }

    @Transactional(Transactional.TxType.SUPPORTS)
    public Page<ForeignTravelResponse> findAll(Optional<String> status, Pageable pageable) {
        Page<ForeignTravelRecord> travels = status
                .map(filter -> repository.findLatestByStatus(filter, pageable))
                .orElseGet(() -> repository.findAllLatestVersions(pageable));
        return travels.map(entity -> mapToResponse(entity, false));
    }

    private void copyRequestToEntity(ForeignTravelRequest request, ForeignTravelRecord target) {
        target.setCountry(request.getCountryName());
        target.setStartDate(request.getFromDate());
        target.setEndDate(request.getToDate());
        target.setStatus(request.getStatus());
        Map<String, Object> details = request.getDetails() == null
                ? new HashMap<>()
                : new HashMap<>(request.getDetails());
        details.put("countryName", request.getCountryName());
        target.setDetails(details);
    }

    private ForeignTravelResponse mapToResponse(ForeignTravelRecord entity, boolean includeDetails) {
        ForeignTravelResponse response = new ForeignTravelResponse();
        response.setId(entity.getRecordId());
        response.setRecordId(entity.getRecordId());
        response.setVersionId(entity.getVersionId());
        response.setCountry(entity.getCountry());
        response.setCountryName(entity.getCountry());
        response.setFromDate(entity.getStartDate());
        response.setToDate(entity.getEndDate());
        response.setStartDate(entity.getStartDate());
        response.setEndDate(entity.getEndDate());
        response.setStatus(entity.getStatus());
        response.setCreatedAt(entity.getCreatedAt());
        response.setUpdatedAt(entity.getUpdatedAt());
        if (includeDetails) {
            response.setDetails(entity.getDetails());
        }
        return response;
    }

    private Individual getOrCreateUser() {
        // Use provided spGlobalId or get from security context
        String spGlobalId1 = securityHelper.getCurrentSpGlobalId();
        String nbisGlobalUserID = securityHelper.getCurrentNbisGlobalUserID();

        if (spGlobalId1 == null || nbisGlobalUserID == null) {
            throw new IllegalStateException("No user identifier provided and no authenticated user found");
        }

        // Check if user exists
        Optional<Individual> existingUser = individualRepository.findByNbisGlobalUserId(nbisGlobalUserID);
        if (existingUser.isPresent()) {
            return existingUser.get();
        }

        // Create new user if not exists
        Individual newUser = new Individual();
        newUser.setSpGlobalLoginId(spGlobalId1);
        newUser.setNbisGlobalUserId(nbisGlobalUserID); // Using same value for now
        // Set timestamps
        OffsetDateTime now = OffsetDateTime.now();
        newUser.setCreatedAt(now);
        newUser.setUpdatedAt(now);

        Individual savedUser = individualRepository.save(newUser);
        log.info("Created new individual with spGlobalLoginId: {}", spGlobalId1);

        return savedUser;
    }

    public ForeignTravelResponse saveInitial(ForeignTravelRequest request, String spGlobalId) {
        ForeignTravelRecord entity = new ForeignTravelRecord();
        entity.setRecordId(UUID.randomUUID());
        entity.setVersionId(1); // First version
        copyRequestToEntity(request, entity);

        // Get or create user and associate with travel
        Individual user = getOrCreateUser();
        entity.setUserId(user.getUserId());

        // Set timestamps
        OffsetDateTime now = OffsetDateTime.now();
        entity.setCreatedAt(now);
        entity.setUpdatedAt(now);

        ForeignTravelRecord saved = repository.save(entity);

        return mapToResponse(saved, true);
    }

    @Transactional
    public ForeignTravelResponse update(UUID recordId, Integer versionId, ForeignTravelRequest request) {
        // Find the specified version or latest version of the record
        ForeignTravelRecord existing;
        if (versionId != null) {
            existing = repository
                    .findById(new ForeignTravelRecord.ForeignTravelRecordId(recordId, versionId))
                    .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s version %d not found".formatted(recordId, versionId)));
        } else {
            existing = repository
                    .findLatestByRecordId(recordId)
                    .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s not found".formatted(recordId)));
        }

        // Create a new version
        ForeignTravelRecord newVersion = new ForeignTravelRecord();
        newVersion.setRecordId(existing.getRecordId());
        newVersion.setVersionId(existing.getVersionId() + 1);
        newVersion.setUserId(existing.getUserId());

        copyRequestToEntity(request, newVersion);

        // Set timestamps
        newVersion.setCreatedAt(existing.getCreatedAt()); // Keep original creation time
        newVersion.setUpdatedAt(OffsetDateTime.now());

        ForeignTravelRecord saved = repository.save(newVersion);

        return mapToResponse(saved, true);
    }

    @Transactional(Transactional.TxType.SUPPORTS)
    public ForeignTravelResponse findLatest(UUID recordId) {
        ForeignTravelRecord entity = repository
                .findLatestByRecordId(recordId)
                .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s not found".formatted(recordId)));
        return mapToResponse(entity, true);
    }

    @Transactional(Transactional.TxType.SUPPORTS)
    public ForeignTravelResponse findById(UUID recordId, Integer versionId) {
        ForeignTravelRecord entity = repository
                .findById(new ForeignTravelRecord.ForeignTravelRecordId(recordId, versionId))
                .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s version %d not found".formatted(recordId, versionId)));
        return mapToResponse(entity, true);
    }

    @Transactional(Transactional.TxType.SUPPORTS)
    public Page<ForeignTravelResponse> list(Optional<String> status, Pageable pageable) {
        Page<ForeignTravelRecord> travels = status
                .map(filter -> repository.findLatestByStatus(filter, pageable))
                .orElseGet(() -> repository.findAllLatestVersions(pageable));
        return travels.map(entity -> mapToResponse(entity, false));
    }

    @Transactional
    public void delete(UUID recordId, Integer versionId) {
        // Verify the record exists before deleting
        repository
                .findById(new ForeignTravelRecord.ForeignTravelRecordId(recordId, versionId))
                .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s version %d not found".formatted(recordId, versionId)));

        // Delete this specific version
        repository.deleteById(new ForeignTravelRecord.ForeignTravelRecordId(recordId, versionId));
    }

    @Transactional
    public ForeignTravelResponse certify(UUID recordId) {
        // Find the latest version of the record
        ForeignTravelRecord existing = repository
                .findLatestByRecordId(recordId)
                .orElseThrow(() -> new ResourceNotFoundException("Foreign travel %s not found".formatted(recordId)));

        // Create a new certified version
        ForeignTravelRecord certifiedVersion = new ForeignTravelRecord();
        certifiedVersion.setRecordId(existing.getRecordId());
        certifiedVersion.setVersionId(existing.getVersionId() + 1);
        certifiedVersion.setUserId(existing.getUserId());
        certifiedVersion.setCountry(existing.getCountry());
        certifiedVersion.setStartDate(existing.getStartDate());
        certifiedVersion.setEndDate(existing.getEndDate());
        certifiedVersion.setStatus("CERTIFIED");
        certifiedVersion.setDetails(existing.getDetails());

        // Set timestamps
        certifiedVersion.setCreatedAt(existing.getCreatedAt());
        certifiedVersion.setUpdatedAt(OffsetDateTime.now());

        ForeignTravelRecord saved = repository.save(certifiedVersion);

        return mapToResponse(saved, true);
    }

    @Transactional(Transactional.TxType.SUPPORTS)
    public List<ForeignTravelResponse> getExportListByRecordIds(List<UUID> recordIds) {
        return recordIds.stream()
                .map(recordId -> {
                    try {
                        return findLatest(recordId);
                    } catch (ResourceNotFoundException e) {
                        log.warn("Record not found for export: {}", recordId);
                        return null;
                    }
                })
                .filter(response -> response != null)
                .collect(Collectors.toList());
    }

}

-----------------------

package com.foreign.travel.security;

import java.util.List;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

@Component
public class SecurityContextHelper {

    public String getCurrentUsername() {
        return getCurrentSpGlobalId();
    }

    public String getCurrentSpGlobalId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated()) {
            if (authentication.getDetails() instanceof JwtAuthenticationDetails details) {
                String spGlobalId = details.getSpGlobalId();
                if (spGlobalId != null && !spGlobalId.isBlank()) {
                    return spGlobalId;
                }
            }
        }
        return null;
    }

    public String getCurrentNbisGlobalUserID() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getDetails() instanceof JwtAuthenticationDetails) {
            JwtAuthenticationDetails details = (JwtAuthenticationDetails) authentication.getDetails();
            return details.getNbisGlobalUserID();
        }
        return null;
    }

    public List<String> getCurrentUserRoles() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getDetails() instanceof JwtAuthenticationDetails) {
            JwtAuthenticationDetails details = (JwtAuthenticationDetails) authentication.getDetails();
            return details.getRoles();
        }
        return null;
    }

    public String getCurrentUserPrimaryRole() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getDetails() instanceof JwtAuthenticationDetails) {
            JwtAuthenticationDetails details = (JwtAuthenticationDetails) authentication.getDetails();
            return details.getPrimaryRole();
        }
        return null;
    }

    public boolean hasRole(String role) {
        List<String> roles = getCurrentUserRoles();
        return roles != null && roles.contains(role);
    }

    public boolean hasAnyRole(String... roles) {
        List<String> userRoles = getCurrentUserRoles();
        if (userRoles != null) {
            for (String role : roles) {
                if (userRoles.contains(role)) {
                    return true;
                }
            }
        }
        return false;
    }
}
-----

package com.foreign.travel.security;

import io.jsonwebtoken.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;

import java.io.InputStream;
import java.security.PublicKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.List;
import java.util.function.Function;

@Component
public class JwtUtil {

    private static final Logger logger = LoggerFactory.getLogger(JwtUtil.class);

    @Value("${security.jwt.certificate-path:certs/localhost.crt}")
    private String certificatePath;

    @Value("${security.jwt.expiration-time:18000000}")
    private long jwtExpiration; // 5 hours in milliseconds (5 * 60 * 60 * 1000)

    @Value("${security.jwt.issuer}")
    private String issuer;

    private PublicKey publicKey;

    private PublicKey getPublicKey() {
        if (publicKey == null) {
            try {
                // Load certificate from classpath
                ClassPathResource resource = new ClassPathResource(certificatePath);
                try (InputStream inputStream = resource.getInputStream()) {
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    X509Certificate certificate = (X509Certificate) certificateFactory.generateCertificate(inputStream);
                    publicKey = certificate.getPublicKey();
                    logger.info("Successfully loaded public key from certificate: {}", certificatePath);
                }
            } catch (Exception e) {
                logger.error("Failed to load public key from certificate: {}", certificatePath, e);
                throw new RuntimeException("Failed to load JWT public key from certificate", e);
            }
        }
        return publicKey;
    }

    public String extractSubjectPersonaObjectId(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    @SuppressWarnings("unchecked")
    public List<String> extractRoles(String token) {
        // Try several common layouts: 'roles', 'permissions', Keycloak 'realm_access.roles'
        List<String> roles = extractClaim(token, claims -> (List<String>) claims.get("roles"));
        if (roles == null || roles.isEmpty()) {
            List<String> permissions = extractClaim(token, claims -> (List<String>) claims.get("permissions"));
            if (permissions != null && !permissions.isEmpty()) {
                roles = permissions.stream().map(this::mapPermissionToRole).distinct().toList();
            }
        }
        if (roles == null || roles.isEmpty()) {
            roles = extractClaim(token, claims -> {
                Object realmAccess = claims.get("realm_access");
                if (realmAccess instanceof java.util.Map<?, ?> map) {
                    Object realmRoles = map.get("roles");
                    if (realmRoles instanceof List<?> list) {
                        return list.stream().map(Object::toString).toList();
                    }
                }
                return null;
            });
        }
        return roles;
    }

    private String mapPermissionToRole(String permission) {
        // Map external service permissions to internal roles
        return switch (permission) {
            case "iep-user" -> "IEP_USER";
            case "admin" -> "ADMIN";
            // Handle generic permissions from external auth service
            case "user" -> "USER";
            case "read" -> "USER";
            case "access" -> "USER";
            default -> {
                logger.debug("Unmapped permission from external token: {}", permission);
                // For external tokens, map unknown permissions to USER instead of UNKNOWN
                // This allows external services to work without exact permission matching
                yield "USER";
            }
        };
    }

    public String extractRole(String token) {
        List<String> roles = extractRoles(token);
        return roles != null && !roles.isEmpty() ? roles.get(0) : null;
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        try {
            // allow small clock skew and verify signature
            return Jwts.parser()
                    .verifyWith(getPublicKey())
                    .build()
                    .parseSignedClaims(token)
                    .getPayload();
        } catch (ExpiredJwtException e) {
            logger.warn("JWT token is expired: {}", e.getMessage());
            throw e;
        } catch (UnsupportedJwtException e) {
            logger.warn("JWT token is unsupported: {}", e.getMessage());
            throw e;
        } catch (MalformedJwtException e) {
            logger.warn("JWT token is malformed: {}", e.getMessage());
            throw e;
        } catch (SecurityException e) {
            logger.warn("JWT signature does not match: {}", e.getMessage());
            throw e;
        } catch (IllegalArgumentException e) {
            logger.warn("JWT token compact of handler are invalid: {}", e.getMessage());
            throw e;
        }
    }

    public boolean isTokenExpired(String token) {
        try {
            return extractExpiration(token).before(new Date());
        } catch (JwtException e) {
            return true;
        }
    }

    public Boolean validateToken(String token, String username) {
        try {
            final String extractedUsername = extractSubjectPersonaObjectId(token);
            return (extractedUsername.equals(username) && !isTokenExpired(token));
        } catch (JwtException e) {
            logger.warn("JWT token validation failed: {}", e.getMessage());
            return false;
        }
    }

    public Boolean validateToken(String token) {
        logger.debug("jwt token : {}", token);

        try {
            Claims claims = extractAllClaims(token);

            // Validate issuer (optional - may not be present in external tokens)
            if (claims.getIssuer() != null && !issuer.equals(claims.getIssuer())) {
                logger.warn("JWT token issuer validation failed. Expected: {}, Actual: {}", issuer, claims.getIssuer());
                // For external tokens, we may be more lenient with issuer validation
                // Only fail if we have strict issuer validation enabled
                logger.info("Proceeding with token validation despite issuer mismatch - external token");
            }

            // Check if token is expired
            if (isTokenExpired(token)) {
                logger.warn("JWT token is expired");
                return false;
            }

            // Validate required claims - use flexible approach for external tokens
            String subjectPersonaObjectId = extractSubjectPersonaObjectId(token);
            List<String> roles = extractRoles(token);

            if (subjectPersonaObjectId == null || subjectPersonaObjectId.trim().isEmpty()) {
                logger.warn("JWT token missing required claim: subject or subjectPersonaObjectId");
                return false;
            }

            if (roles == null || roles.isEmpty()) {
                logger.warn("JWT token missing required claim: roles or permissions");
                return false;
            }

            // Check for unknown roles (invalid permissions)
            // Note: We now map unknown permissions to "USER" for external token compatibility
            if (roles.contains("UNKNOWN")) {
                logger.warn("JWT token contains unrecognized permissions that cannot be mapped to valid roles");
                return false;
            }

            return true;
        } catch (JwtException e) {
            logger.warn("JWT token validation failed: {}", e.getMessage());
            return false;
        }
    }

    /**
     * Extract the user's spGlobalId from the JWT token.f
     * Tries multiple claim fields in order of preference:
     * 1. spGlobalId (custom claim)
     * 2. null if none found
     *
     * @param token The JWT token string
     * @return The spGlobalId
     * @throws JwtException if token is invalid or expired
     */
    public String extractSpGlobalId(String token) {
        return extractClaim(token, claims -> {
            Object direct = claims.get("spGlobalId");
            if (direct instanceof String directString && !directString.isBlank()) {
                return directString;
            }

            return null;
        });

    }

    public String extractNbisGlobalUserID(String token) {
        return extractClaim(token, claims -> {
            Object direct = claims.get("nbisGlobalUserID");
            if (direct instanceof String directString && !directString.isBlank()) {
                return directString;
            }

            return null;
        });

    }

}

