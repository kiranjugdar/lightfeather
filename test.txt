import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.session.SessionInformation;
import org.springframework.security.core.session.SessionRegistry;
import org.springframework.security.web.authentication.logout.LogoutHandler;
import org.springframework.stereotype.Component;

@Component
public class SessionCleanupLogoutHandler implements LogoutHandler {

    private final SessionRegistry sessionRegistry;

    public SessionCleanupLogoutHandler(SessionRegistry sessionRegistry) {
        this.sessionRegistry = sessionRegistry;
    }

    @Override
    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
        // Retrieve current session.
        if (request.getSession(false) != null) {
            String sessionId = request.getSession().getId();
            // Remove the session from the registry.
            SessionInformation sessionInformation = sessionRegistry.getSessionInformation(sessionId);
            if (sessionInformation != null) {
                sessionInformation.expireNow();
                sessionRegistry.removeSessionInformation(sessionId);
            }
            // Invalidate the HTTP session.
            request.getSession().invalidate();
        }
    }
}


-------

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.session.SessionRegistry;
import org.springframework.security.core.session.SessionRegistryImpl;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SessionRegistry sessionRegistry() {
        return new SessionRegistryImpl();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain samlSecurityChain(HttpSecurity http, SessionCleanupLogoutHandler logoutHandler) throws Exception {
        http
            .securityMatcher("/**")
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(
                    "/public/**", "/landing", "/proceed", "/actuator/health",
                    "/favicon.ico", "/css/**", "/js/**", "/images/**", "/webjars/**",
                    "/login", "/saml2/**", "/login/saml2/**"
                ).permitAll()
                .anyRequest().authenticated()
            )
            .saml2Login(saml -> saml
                .successHandler(samlSuccessHandler())  // your custom SAML success handler
            )
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/login?logout")
                .logoutHandlers(logoutHandler)   // add your custom logout handler here
                .invalidateHttpSession(true)
                .deleteCookies("JSESSIONID")
            )
            .sessionManagement(session -> session
                .maximumSessions(1)
                .maxSessionsPreventsLogin(true)
                .sessionRegistry(sessionRegistry())
            );

        // Optionally add your custom session check filter here.
        // http.addFilterAfter(new ConcurrentSessionBlockingFilter(sessionRegistry()),
        //         SecurityContextPersistenceFilter.class);

        return http.build();
    }

    // Define your custom SAML success handler as needed.
    @Bean
    public SamlAuthenticationSuccessHandler samlSuccessHandler() {
        return new SamlAuthenticationSuccessHandler();
    }
}
